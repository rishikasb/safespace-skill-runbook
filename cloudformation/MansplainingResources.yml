AWSTemplateFormatVersion: "2010-09-09"
Description: Preparing AWS resources form mansplaining.
Parameters: 
  UniqueID: 
    Type: String
    Default: yourinitials
    Description: Enter your initials in lower case as a unique identifier for components created 
    AllowedPattern: "^([a-z]|(d(?!d{0,2}.d{1,3}.d{1,3}.d{1,3})))([a-zd]|(.(?!(.|-)))|(-(?!.))){1,61}[a-zd.]$"

Resources:
  MansplainingS3Bucket:
    Type: AWS::S3::Bucket
    Properties: 
      AccessControl: BucketOwnerFullControl
      VersioningConfiguration: 
        Status: Enabled
      BucketName:
        Fn::Join:
          - ""
          - - "mansplaining-"
            - !Ref UniqueID
            - "-"
            - !Select
             - 0
             - !Split
              - "-"
              - !Select
                - 2
                - !Split
                  - "/"
                  - !Ref "AWS::StackId"


  TranscribeLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.6
      Handler: index.lambda_handler
      Role: !GetAtt [TranscribeLambdaExecutionRole, Arn]
      Timeout: 900
      Code:
        ZipFile: !Join
          - |+

          - - import json
            - import boto3
            - import time
            - transcribe = boto3.client('transcribe')
            - s3_resource = boto3.resource('s3')

            - 'def lambda_handler(event,context):'
            - '    #print("event is: %", event)'
            - '    record = event["Records"][0]'
            - '    #print("Record is ", record)'
            - '    region = record["awsRegion"]'
            - '    #print("region is ", region)'
            - '    bucket = record["s3"]["bucket"]["name"]'
            - '    #print("bucket is ", bucket)'
            - '    key = record["s3"]["object"]["key"]'
            - '    print("key is ", key)'

            - '    job_uri = "https://" + bucket + ".s3-" + region + ".amazonaws.com/" + key'
            - '    print("job_uri ", job_uri)'

            - '    ##Start the transcription job'
            - '    timestamp = time.strftime("-%Y-%m-%d-%H-%M-%S", time.gmtime())'

            - '    job_name = "transcribe_meeting_recording" +  timestamp'

            - '    transcribe.start_transcription_job('
            - '                    TranscriptionJobName=job_name, '
            - '                    Media={"MediaFileUri": job_uri},'
            - '                    MediaFormat="mp4",'
            - '                    LanguageCode="en-US",'
            - '                    OutputBucketName=bucket,'
            - '                    Settings= {'
            - '                        "ShowSpeakerLabels": True,'
            - '                        "MaxSpeakerLabels":10'
            - '                    }'
            - '    )'

            - '    while True:'
            - '        status = transcribe.get_transcription_job(TranscriptionJobName=job_name)'
            - '        if status["TranscriptionJob"]["TranscriptionJobStatus"] in ["COMPLETED", "FAILED"]:'
            - '            break'
            - '        print("Transcribe Job Running...")'
            - '        time.sleep(5)'

            - '    print(status)'
            - '    #print("######")'
            - '    transcribed_meeting = status["TranscriptionJob"]["Transcript"]["TranscriptFileUri"]'
            - '    transcribed_meeting_keys = transcribed_meeting.split("/")'
            - '    transcribed_meeting_key = transcribed_meeting_keys[-1]'

            - '    print("transcribed_meeting_key ", transcribed_meeting_key)'

            - '    # Copy the transcribed meeting to Output folder'
            - '    copy_source = {'
            - '      "Bucket": bucket,'
            - '      "Key": transcribed_meeting_key'
            - '    }'

            - '    s3_resource.meta.client.copy(copy_source,Bucket=bucket,Key="meeting-transcriptions/"+transcribed_meeting_key)'

            - '    # Delete the original transcribed meeting'
            - '    s3_resource.Object(bucket, transcribed_meeting_key).delete()'

            - '    return "Completed transcribing the meeting recording" '

  TranscribeLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonTranscribeFullAccess
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - arn:aws:iam::aws:policy/CloudWatchFullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      RoleName:
        Fn::Join:
          - ""
          - - "Mansplaining-Transcribe-Lambda-ServiceRole-"
            - !Ref UniqueID

  TranscribeLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !GetAtt TranscribeLambda.Arn
      Action: 'lambda:InvokeFunction'
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Sub 'arn:aws:s3:::${MansplainingS3Bucket}'


  AnalyzeMeetingLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.6
      Handler: index.lambda_handler
      Role: !GetAtt [AnalyzeMeetingLambdaExecutionRole, Arn]
      Timeout: 900
      Code:
        ZipFile: !Join
          - |+

          - - import json
            - import boto3
            - import time
            - s3_resource = boto3.resource('s3')
            - elastictranscoder_client = boto3.client('elastictranscoder')

            - 'def lambda_handler(event,context):'
            - '  #Get the filename(key) that caused the event.'
            - '  record = event["Records"][0]'
            - '  region = record["awsRegion"]'
            - '  bucket = record["s3"]["bucket"]["name"]'
            - '  key = record["s3"]["object"]["key"]'
            - '  print("key is ", key)'

            - '  #Get the content of the file'
            - '  obj = s3_resource.Object(bucket, key)'
            - '  body = obj.get()["Body"].read()'
            - '  json_content = json.loads(body)'

            - '  #Get the transcription results'
            - '  transcription_results = json_content["results"]'

            - '  #Get the speaker times from the transcript'
            - '  times = []'
            - '  for segment in transcription_results["speaker_labels"]["segments"]:'
            - '      start_time = float(segment["start_time"])'
            - '      end_time = float(segment["end_time"])'

            - '      # get a 1/2 second snippet after each speaker starts'
            - '      delta = .5'

            - '      times.append((start_time, delta))'

            - '  print("Speaker times ")'
            - '  print(times)'

            - '  ##Form the inputs to elastic transcoder.'
            - '  inputs = []'
            - '  for start_time, duration in times:'
            - '      json_obj = {'
            - '          "Key": "meeting-recordings/Border Security Part1.m4a",'
            - '          "TimeSpan": {'
            - '              "StartTime": str(start_time),'
            - '              "Duration": str(duration)'
            - '          }'
            - '      }'
            - '      inputs.append(json_obj)'
            - '  print("Number of inputs ", len(inputs))'
            - '  print(inputs)'

            - '  ##Form the outputs to elastic transcoder.'
            - '  outputs = []'
            - '  for idx in range(len(times)):'
            - '      json_obj = {'
            - '          "Key": "micro_clip_{}.wav".format(idx),'
            - '          # configure this by looking at the console based on the type of audio file you want '
            - '          "PresetId":"1351620000001-300300"'
            - '      }'
            - '      outputs.append(json_obj)'
            - '  print("Number of outputs ", len(outputs))'
            - '  print(outputs)'

            - '  pipeline = elastictranscoder_client.create_pipeline('
            - '      Name="mansplaining_pipeline",'
            - '      InputBucket=bucket,'
            - '      OutputBucket=bucket,'
            - '      Role="arn:aws:iam::923611210851:role/service-role/AmazonSageMaker-ExecutionRole-20191229T181432")'

            - '  pipeline_id = pipeline["Pipeline"]["Id"]'
            - '  print(" Pipeline ID is ", pipeline_id)'

            - '  create_job_responses = []'
            - '  transcoder_jobs = []'


            - '  #need to loop through batches of 30  (TODO : make this configurable)'
            - '  iterator = round(len(inputs)/5)'
            - '  for i in range(iterator):'
            - '    print(i)'
            - '    lb = i * 5'
            - '    up = lb + 5'
            - '    if up > len(inputs):'
            - '      up = len(inputs)'
            - '    create_job_response = elastictranscoder_client.create_job('
            - '       PipelineId=pipeline_id,'
            - '       Inputs=inputs[lb:up],'
            - '       Outputs = outputs[lb:up] )'
            - '    print("create_job_response ", create_job_response)'
            - '    create_job_responses.append(create_job_response)'
            - '    job_id = create_job_response["Job"]["Id"]'
            - '    transcoder_jobs.append(job_id)'

            - '  #Wait for the jobs to be completed.'
            - '  print("Elastic Transcoder Jobs: ", transcoder_jobs )'
            - '  for job in transcoder_jobs:'
            - '    while True:'
            - '      response = elastictranscoder_client.read_job('
            - '        Id=job'
            - '      ) '
            - '      job_status = response["Job"]["Output"]["Status"]  '
            - '      print("******* job_id ", job, " status is ", job_status)'
            - '      if job_status in ["Complete", "Failed"]:'
            - '        break;'

            - '  #Now move the WAV parts to their own directory.'
            - '  for create_job_response in create_job_responses:'
            - '    transcoder_ouputs = create_job_response["Job"]["Outputs"]'
            - '    print("transcoder outputs ", transcoder_ouputs)'
            - '    for transcoder_output in transcoder_ouputs:'
            - '      transcoder_output_key = transcoder_output["Key"]'
            - '      print("transcoder_output_key ", transcoder_output_key)'
            - '      #Copy the transcribed meeting to Output folder'
            - '      copy_source = {'
            - '        "Bucket": bucket,'
            - '        "Key": transcoder_output_key'
            - '      }'
            - '      output_key = "meeting-WAV-Parts/"+transcoder_output_key'
            - '      try :'
            - '         s3_resource.meta.client.copy(copy_source,Bucket=bucket,Key=output_key)'
            - '         # Delete the original transcribed meeting'
            - '         s3_resource.Object(bucket, transcoder_output_key).delete()'
            - '      except e:'
            - '         print("Error copying WAV file")'
            - '         continue'

            - '  return "Completed transcribing the meeting recording" '

  AnalyzeMeetingLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
          - arn:aws:iam::aws:policy/AmazonElasticTranscoder_FullAccess
          - arn:aws:iam::aws:policy/AmazonS3FullAccess
          - arn:aws:iam::aws:policy/CloudWatchFullAccess
          - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      RoleName:
        Fn::Join:
          - ""
          - - "Mansplaining-AnalyzeMeeting-Lambda-ServiceRole-"
            - !Ref UniqueID

  AnalyzeMeetingLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !GetAtt AnalyzeMeetingLambda.Arn
      Action: 'lambda:InvokeFunction'
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Sub 'arn:aws:s3:::${MansplainingS3Bucket}'

Outputs:
      MansplainingS3Bucket:
        Description: Mansplaining bucket name
        Value: !Ref MansplainingS3Bucket


